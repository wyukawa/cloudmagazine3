package cloud.magazine.vol3;

import java.util.Scanner;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

//レコメンデーションメインクラス
public class CafeteriaRecommendation extends Configured implements Tool {

	// レコメンデーションの各ジョブが出力するファイルの出力先
	private static final String STR_ROOT_DIR = "cafeteria_recommendation/";
	private static final Path ROOT_DIR = new Path(STR_ROOT_DIR);

	// 正規化ジョブの結果出力先
	private static final Path NORMARIZE_OUTPUT_PATH = new Path(STR_ROOT_DIR
			+ "normarize.out");

	// 偏差計算ジョブの結果出力先
	private static final Path DEVIATION_OUTPUT_PATH = new Path(STR_ROOT_DIR
			+ "deviation.out");

	// クラスタリングジョブの結果出力先
	private static final Path CLUSTERING_OUTPUT_PATH = new Path(STR_ROOT_DIR
			+ "clustering.out");

	// クラスタリングジョブを開始するメソッド
	public int runClusteringJob() throws Exception {

		Job job = new Job(getConf(), "Clustering Job");
		job.setJarByClass(CafeteriaRecommendation.class);

		// クラスタリングジョブで使用するMapperクラス,Reducerクラスの設定
		job.setMapperClass(ClusteringMapper.class);
		job.setReducerClass(ClusteringReducer.class);

		// 偏差計算ジョブで計算した値が記録されているファイルを入力にする
		FileInputFormat.addInputPath(job, DEVIATION_OUTPUT_PATH);

		// クラスタリングジョブの出力ファイル
		FileOutputFormat.setOutputPath(job, CLUSTERING_OUTPUT_PATH);

		// map関数の出力keyはreduce関数の出力keyと同じ型(NullWritable)ではないので、明示的に設定。
		job.setMapOutputKeyClass(Text.class);

		// reduce関数の出力keyとvalue。
		job.setOutputKeyClass(NullWritable.class);
		job.setOutputValueClass(Text.class);

		System.out
				.println("#################### Stargting Clustering Job! ####################");
		return job.waitForCompletion(true) ? 0 : 1;
	}

	// 偏差計算ジョブを開始するメソッド
	public int runDeviationJob(String targetName) throws Exception {

		Configuration conf = getConf();

		// プロパティに設定された推薦対象者の名前を取得
		conf.set("targetName", targetName);

		Job job = new Job(conf, "Deviation Job");
		job.setJarByClass(CafeteriaRecommendation.class);

		// 偏差計算ジョブで使用するMapperクラス,Reducerクラスの設定
		job.setMapperClass(DeviationMapper.class);
		job.setReducerClass(DeviationReducer.class);

		// 正規化ジョブで利用者が各メニューを食べた回数を
		// 正規化した結果が記録されているファイルを入力にする。
		FileInputFormat.addInputPath(job, NORMARIZE_OUTPUT_PATH);

		// 偏差を計算した結果が記録される出力ファイル
		FileOutputFormat.setOutputPath(job, DEVIATION_OUTPUT_PATH);

		// map関数の出力keyはreduce関数の出力keyと同じ型(NullWritable)ではないので、明示的に設定
		job.setMapOutputKeyClass(Text.class);

		// reduce関数の出力keyとvalue
		job.setOutputKeyClass(NullWritable.class);
		job.setOutputValueClass(Text.class);

		System.out
				.println("#################### Starting Deviation Job! ####################");
		return job.waitForCompletion(true) ? 0 : 1;
	}

	// 正規化ジョブを開始するメソッド
	public int runNormarizeJob(String inputPath) throws Exception {

		Job job = new Job(getConf(), "Normarize Job");
		job.setJarByClass(CafeteriaRecommendation.class);

		// 正規化ジョブで使用するMapperクラス,Reducerクラスの設定
		job.setMapperClass(NormarizeMapper.class);
		job.setReducerClass(NormarizeReducer.class);

		// 食堂での食事履歴を入力ファイルにする。
		FileInputFormat.addInputPath(job, new Path(inputPath));

		// 各メニューを食べた回数が正規化された結果が記録される出力ファイル
		FileOutputFormat.setOutputPath(job, NORMARIZE_OUTPUT_PATH);

		// map関数の出力keyはreduce関数の出力keyと同じ型(NullWritable)ではないので、明示的に設定
		job.setMapOutputKeyClass(Text.class);

		// reduce関数の出力keyとvalue
		job.setOutputKeyClass(NullWritable.class);
		job.setOutputValueClass(Text.class);

		System.out
				.println("#################### Starting Normarize Job! ####################");
		return job.waitForCompletion(true) ? 0 : 1;

	}

	// ジョブ開始のメインメソッド
	// 3つのジョブはこのメソッドから実行される
	public int run(String[] args) throws Exception {

		String targetName = args[0]; // 推薦対象の利用者
		String inputPath = args[1]; // HDFS上の食事履歴のパス
		int status; // 各ジョブの終了ステータス
		FileSystem rootFS = FileSystem.get(getConf());

		try {

			// レコメンデーションの実行前に以前実行したときのファイルが残っていたら消すか尋ねる。
			if (rootFS.exists(ROOT_DIR)) {
				System.out
						.println("Do you delete the FILEs generated by former Recommendation? (yes/NO) :");

				String confirm = new Scanner(System.in).next();

				if (confirm.equals("yes")) {
					cleanup(rootFS);
				} else {
					System.out
							.println("Recommendation can’t start because the files generated by former Recommendation remain.");
					return 1;
				}
			}

			// 正規化ジョブ実行
			status = runNormarizeJob(inputPath);

			if (status != 0) {
				return status;
			}

			// 偏差計算ジョブ実行
			status = runDeviationJob(targetName);

			if (status != 0) {
				return status;
			}

			// クラスタリングジョブ実行
			status = runClusteringJob();

			if (status == 0) {
				// 3つのジョブが全て正常終了したら、推薦結果を表示する。
				showRecommendationResult(rootFS);
			}

			return status;
		} finally {
			rootFS.close();
		}
	}

	// 以前レコメンデーションを実行したときのファイルを削除するメソッド
	public void cleanup(FileSystem fs) throws Exception {

		fs.delete(ROOT_DIR, true);

	}

	// 推薦結果を表示するメソッド
	public void showRecommendationResult(FileSystem fs) throws Exception {

		FileStatus[] statusList = fs.listStatus(CLUSTERING_OUTPUT_PATH);
		long size;
		byte[] buffer;

		for (FileStatus status : statusList) {
			Path file = status.getPath();

			if (!file.getName().startsWith("part-r")) {
				continue;
			}

			FSDataInputStream inputStream = fs.open(file);
			size = status.getLen();
			buffer = new byte[(int) size];

			inputStream.readFully(0, buffer);
			inputStream.close();

			System.out.println(new String(buffer));

		}
	}

	public static void main(String[] args) throws Exception {

		int status = ToolRunner.run(new CafeteriaRecommendation(), args);
		System.exit(status);
	}
}